model の　validation　　のテストの場合、有効なユーザーがちゃんと有効なユーザーとして扱われるか、無効なユーザーがちゃんと無効のユーザーとして扱われるか、両方のテストを書く

ユーザーに関するモデルでテストすべき項目
* 存在性
* 長さ
* メールアドレスのフォーマット
* メールアドレスの一意性
* fixtureは初期状態では、メールアドレスに一意性を持っていない

has_secure_password のテスト
* テスト用のユーザーに、password,password_confirmationを追加
* passwordとpassword_confirmationが等しく、かつ存在性と長さが有効かどうかのテストを書く

formのテスト
* 統合テストで行う
* 無効なユーザー、有効なユーザーで登録しようとするpostリクエストをそれぞれ送信
* 無効なユーザーの場合は、データベースに保存されないか(データベースのユーザーの数が、リクエストの送信前後で変わらないか)
* 有効なユーザーの場合は、データベースに保存されているか(データベースのユーザーの数が、リクエストの送信後に増えるか)

ユーザー更新の場合
* 更新したい情報をpatchリクエストで送信
* reloadでDBの最新の情報を読み込み直して、正しく更新されているか
* passwordが空でも更新できるようにバリデーションを変更しないと、REDになる
```
get edit_user_path(@user)
    assert_template 'users/edit'
    name  = "Foo Bar"
    email = "foo@bar.com"
    patch user_path(@user), params: { user: { name:  name,
                                              email: email,
                                              password:              "",
                                              password_confirmation: "" } }
    assert_not flash.empty?
    assert_redirected_to @user
    @user.reload
    assert_equal name,  @user.name
    assert_equal email, @user.email                                          
 ```

flash のテスト
* flashの中身が空でないかどうか
